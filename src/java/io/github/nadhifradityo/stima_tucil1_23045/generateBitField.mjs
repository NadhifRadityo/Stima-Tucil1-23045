import fs from "fs/promises"
import fs0 from "fs"
import path from "path"
import url from "url"

const __dirname = path.dirname(url.fileURLToPath(import.meta.url));

const storeType = "long";
const storeSize = 64;
const width = 16;
const height = 16;
const depth = 16;
const slots = Math.ceil((width * height * depth) / storeSize);
const batch = 16;
const slotBatch = Math.ceil(slots / batch);
const source = `
// Do NOT edit this file. This file was generated.

package io.github.nadhifradityo.stima_tucil1_23045;

public class BitField {
	public static final int WIDTH = ${width};
	public static final int HEIGHT = ${height};
	public static final int DEPTH = ${depth};
${new Array(slots).fill().map((_, i) => i).map(i => `	protected ${storeType} _${i};`).join("\n")}

	public boolean get(int x, int y, int z) {
		assert x >= 0 && x < WIDTH;
		assert y >= 0 && y < HEIGHT;
		assert z >= 0 && z < DEPTH;
		int position = z * (HEIGHT * WIDTH) + y * WIDTH + x;
${new Array(slotBatch).fill().map((_, i) => i).map(i => `		if(position < ${(i + 1) * batch * storeSize}) return this.get${i}(position);`).join("\n")}
		assert false;
		return false;
	}
${new Array(slotBatch).fill().map((_, i) => i).map(i => `
	protected boolean get${i}(int position) {
		int offset = ${storeSize} - position % ${storeSize};
		int mask = 1 << offset;
${new Array(batch).fill().map((_, j) => i * batch + j).filter(j => j < slots).map(j => `		if(position < ${(j + 1) * storeSize}) return (this._${j} & mask) != 0;`).join("\n")}
		assert false;
		return false;
	}
`.slice(1, -1)).join("\n")}

	public void set(int x, int y, int z, boolean v) {
		assert x >= 0 && x < WIDTH;
		assert y >= 0 && y < HEIGHT;
		assert z >= 0 && z < DEPTH;
		int position = z * (HEIGHT * WIDTH) + y * WIDTH + x;
${new Array(slotBatch).fill().map((_, i) => i).map(i => `		if(position < ${(i + 1) * batch * storeSize}) { this.set${i}(position, v); return; }`).join("\n")}
		assert false;
	}
${new Array(slotBatch).fill().map((_, i) => i).map(i => `
	protected void set${i}(int position, boolean v) {
		int offset = ${storeSize} - position % ${storeSize};
		int mask = ~(1 << offset);
		int value = v ? 1 << offset : 0;
${new Array(batch).fill().map((_, j) => i * batch + j).filter(j => j < slots).map(j => `		if(position < ${(j + 1) * storeSize}) { this._${j} = (this._${j} & mask) | value; return; }`).join("\n")}
		assert false;
	}
`.slice(1, -1)).join("\n")}

	public boolean isIntersecting(BitField that) {
${new Array(slotBatch).fill().map((_, i) => i).map(i => `		if(this.isIntersecting${i}(that)) return true;`).join("\n")}
		return false;
	}
${new Array(slotBatch).fill().map((_, i) => i).map(i => `
	protected boolean isIntersecting${i}(BitField that) {
${new Array(batch).fill().map((_, j) => i * batch + j).filter(j => j < slots).map(j => `		if((this._${j} & that._${j}) != 0) return true;`).join("\n")}
		return false;
	}
`.slice(1, -1)).join("\n")}

	public void union(BitField that) {
${new Array(slotBatch).fill().map((_, i) => i).map(i => `		this.union${i}(that);`).join("\n")}
	}
${new Array(slotBatch).fill().map((_, i) => i).map(i => `
	protected void union${i}(BitField that) {
${new Array(batch).fill().map((_, j) => i * batch + j).filter(j => j < slots).map(j => `		this._${j} |= that._${j};`).join("\n")}
	}
`.slice(1, -1)).join("\n")}

	public void intersect(BitField that) {
${new Array(slotBatch).fill().map((_, i) => i).map(i => `		this.intersect${i}(that);`).join("\n")}
	}
${new Array(slotBatch).fill().map((_, i) => i).map(i => `
	protected void intersect${i}(BitField that) {
${new Array(batch).fill().map((_, j) => i * batch + j).filter(j => j < slots).map(j => `		this._${j} &= that._${j};`).join("\n")}
	}
`.slice(1, -1)).join("\n")}

	public void exclusive(BitField that) {
${new Array(slotBatch).fill().map((_, i) => i).map(i => `		this.exclusive${i}(that);`).join("\n")}
	}
${new Array(slotBatch).fill().map((_, i) => i).map(i => `
	protected void exclusive${i}(BitField that) {
${new Array(batch).fill().map((_, j) => i * batch + j).filter(j => j < slots).map(j => `		this._${j} ^= that._${j};`).join("\n")}
	}
`.slice(1, -1)).join("\n")}

	public void complement() {
${new Array(slotBatch).fill().map((_, i) => i).map(i => `		this.complement${i}();`).join("\n")}
	}
${new Array(slotBatch).fill().map((_, i) => i).map(i => `
	protected void complement${i}() {
${new Array(batch).fill().map((_, j) => i * batch + j).filter(j => j < slots).map(j => `		this._${j} = ~this._${j};`).join("\n")}
	}
`.slice(1, -1)).join("\n")}

	public void subtract(BitField that) {
${new Array(slotBatch).fill().map((_, i) => i).map(i => `		this.subtract${i}(that);`).join("\n")}
	}
${new Array(slotBatch).fill().map((_, i) => i).map(i => `
	protected void subtract${i}(BitField that) {
${new Array(batch).fill().map((_, j) => i * batch + j).filter(j => j < slots).map(j => `		this._${j} &= ~that._${j};`).join("\n")}
	}
`.slice(1, -1)).join("\n")}
}
`;
console.log(source);

const outputFile = path.join(__dirname, "BitField.java");
await fs.writeFile(outputFile, source, "utf-8");
