import fs from "fs/promises"
import fs0 from "fs"
import path from "path"
import url from "url"

const __dirname = path.dirname(url.fileURLToPath(import.meta.url));

/**
 * @template {T}
 * @param {T[]} a
 * @param {number} n
 * @returns {T[][]}
 */
const splitEvery = (a, n) => {
	const result = [];
	for(let i = 0; i < a.length; i += n)
		result.push(a.slice(i, i + n));
	return result;
};
/**
 * @param {BigInt} x
 * @returns {BigInt}
 */
const toSigned64 = x => (x & 0x7FFFFFFFFFFFFFFFn) - (x & 0x8000000000000000n);

/**
 * @typedef {Object} GeneratorOpts
 * @property {string} storeType
 * @property {number} storeSize
 * @property {number} width
 * @property {number} height
 * @property {number} depth
 * @property {number} batch
 */

const generateSource = async (/** @type {GeneratorOpts} */ opts) => {
	const {
		width,
		height,
		depth,
		batch
	} = opts;
	const storeType = "long";
	const storeSize = 64;
	const slots = Math.ceil((width * height * depth) / storeSize);
	const slotBatch = Math.ceil(slots / batch);

	/**
	 * @param {number} x
	 * @param {number} y
	 * @param {number} z
	 * @returns {number}
	 */
	const positionAt = (x, y, z) => {
		if(x < 0 || x >= width) throw new Error("X index out of range");
		if(y < 0 || y >= height) throw new Error("Y index out of range");
		if(z < 0 || z >= depth) throw new Error("Z index out of range");
		return z * (height * width) + y * width + x;
	};
	/**
	 * @param {number} p
	 * @returns {number}
	 */
	const positionLoc = p => Math.floor(p / storeSize);
	/**
	 * @param {number} p
	 * @returns {number}
	 */
	const positionOffset = p => (storeSize - 1) - p % storeSize;

	/**
	 * @param {number[]} fromPositions
	 * @param {number} toPositions
	 * @returns {string[]}
	 */
	const generateSourceOffset = (fromPositions, toPositions) => {
		/** @type {[number, number][]} */
		const flos = fromPositions.map(p => [positionLoc(p), positionOffset(p)]).sort(([l1, o1], [l2, o2]) => (l1 * storeSize + o1) - (l2 * storeSize + o2));
		/** @type {[number, number][]} */
		const tlos = toPositions.map(p => [positionLoc(p), positionOffset(p)]).sort(([l1, o1], [l2, o2]) => (l1 * storeSize + o1) - (l2 * storeSize + o2));
		const glos = new Array(fromPositions.length).fill().reduce((/** @type {[number, number, number][]} */ a, _, i) => {
			const [l1, o1] = flos[i];
			const [l2, o2] = tlos[i];
			const [pl1, po1, pl2, po2, l] = a.at(-1) ?? [];
			if(l1 != pl1 || o1 != po1 + l || l2 != pl2 || o2 != po2 + l) {
				a.push([l1, o1, l2, o2, 1]);
				return a;
			}
			a.at(-1)[4]++;
			return a;
		}, []).filter(([l1, o1, l2, o2, l]) => l1 != l2 || o1 != o2);
		return glos.map(([l1, o1, l2, o2, l]) => {
			const mask = toSigned64((1n << BigInt(l)) - 1n);
			const o2Mask = toSigned64((mask << BigInt(o2)) & 0xFFFFFFFFFFFFFFFFn);
			const o2nMask = toSigned64(o2Mask ^ 0xFFFFFFFFFFFFFFFFn);
			if(o1 == o2)
				return `this._${l2} = (this._${l2} & ${o2nMask}L) | (this._${l1} & ${o2Mask}L);`;
			else if(o1 > o2)
				return `this._${l2} = (this._${l2} & ${o2nMask}L) | ((this._${l1} >> ${o1 - o2}) & ${o2Mask}L);`;
			else
				return `this._${l2} = (this._${l2} & ${o2nMask}L) | ((this._${l1} << ${o2 - o1}) & ${o2Mask}L);`;
		});
	}
	/**
	 * @param {string} name
	 * @param {number} amountX
	 * @param {number} amountY
	 * @param {number} amountZ
	 * @returns {string}
	 */
	const generateSourceOffsetXYZ = (name, amountX, amountY, amountZ) => {
		const fromPositions = [];
		const toPositions = [];
		for(let x = 0; x < width; x++) {
			const tx = x + amountX;
			if(tx < 0 || tx >= width) continue;
			for(let y = 0; y < height; y++) {
				const ty = y + amountY;
				if(ty < 0 || ty >= height) continue;
				for(let z = 0; z < depth; z++) {
					const tz = z + amountZ;
					if(tz < 0 || tz >= depth) continue;
					fromPositions.push(positionAt(x, y, z));
					toPositions.push(positionAt(tx, ty, tz));
				}
			}
		}
		const moves = generateSourceOffset(fromPositions, toPositions).map(m => `		${m}`);
		const movesBatched = splitEvery(moves, batch);
		return (
`
	protected void ${name}() {
${movesBatched.map((_, i) => `
		this.${name}${String.fromCharCode(65 + i)}();
`.slice(1, -1)).join("\n")}
	}
${movesBatched.map((m, i) => `
	protected void ${name}${String.fromCharCode(65 + i)}() {
${m.join("\n")}
	}
`.slice(1, -1)).join("\n")}
`).slice(1, -1);
};
	const offsetSteps = [4,2,1];

	const Class = `BitField${width}x${height}x${depth}`;
	const source = `
// Do NOT edit this file. This file was generated.

package io.github.nadhifradityo.stima_tucil1_23045;

public class ${Class} implements BitField {
	public static final int WIDTH = ${width};
	public static final int HEIGHT = ${height};
	public static final int DEPTH = ${depth};
${new Array(slots).fill().map((_, i) => i).map(i => `	protected ${storeType} _${i};`).join("\n")}

	public int getWidth() {
		return WIDTH;
	}
	public int getHeight() {
		return HEIGHT;
	}
	public int getDepth() {
		return DEPTH;
	}

	public boolean getValue(int x, int y, int z) {
		assert x >= 0 && x < WIDTH;
		assert y >= 0 && y < HEIGHT;
		assert z >= 0 && z < DEPTH;
		int position = z * (HEIGHT * WIDTH) + y * WIDTH + x;
${new Array(slotBatch).fill().map((_, i) => i).map(i => `		if(position < ${(i + 1) * batch * storeSize}) return this.getValue${i}(position);`).join("\n")}
		assert false;
		return false;
	}
${new Array(slotBatch).fill().map((_, i) => i).map(i => `
	protected boolean getValue${i}(int position) {
		long mask = 1L << (${storeSize - 1} - position % ${storeSize});
${new Array(batch).fill().map((_, j) => i * batch + j).filter(j => j < slots).map(j => `		if(position < ${(j + 1) * storeSize}) return (this._${j} & mask) != 0;`).join("\n")}
		assert false;
		return false;
	}
`.slice(1, -1)).join("\n")}

	public void setValue(int x, int y, int z, boolean v) {
		assert x >= 0 && x < WIDTH;
		assert y >= 0 && y < HEIGHT;
		assert z >= 0 && z < DEPTH;
		int position = z * (HEIGHT * WIDTH) + y * WIDTH + x;
${new Array(slotBatch).fill().map((_, i) => i).map(i => `		if(position < ${(i + 1) * batch * storeSize}) { this.setValue${i}(position, v); return; }`).join("\n")}
		assert false;
	}
${new Array(slotBatch).fill().map((_, i) => i).map(i => `
	protected void setValue${i}(int position, boolean v) {
		long mask = ~(1L << (${storeSize - 1} - position % ${storeSize}));
		long value = v ? 1L << (${storeSize - 1} - position % ${storeSize}) : 0;
${new Array(batch).fill().map((_, j) => i * batch + j).filter(j => j < slots).map(j => `		if(position < ${(j + 1) * storeSize}) { this._${j} = (this._${j} & mask) | value; return; }`).join("\n")}
		assert false;
	}
`.slice(1, -1)).join("\n")}

	public void offsetX(int amount) {
		if(amount > 0) {
${offsetSteps.map(step => `
			while((amount / ${step}) > 0) {
				this.offsetPX${step}();
				amount -= ${step};
			}
`.slice(1, -1)).join("\n")}
		} else {
			amount *= -1;
${offsetSteps.map(step => `
			while((amount / ${step}) > 0) {
				this.offsetNX${step}();
				amount -= ${step};
			}
`.slice(1, -1)).join("\n")}
		}
		assert amount == 0;
	}
${offsetSteps.map(step => `
${generateSourceOffsetXYZ(`offsetPX${step}`, step, 0, 0)}
`.slice(1, -1)).join("\n")}
${offsetSteps.map(step => `
${generateSourceOffsetXYZ(`offsetNX${step}`, -step, 0, 0)}
`.slice(1, -1)).join("\n")}

	public void offsetY(int amount) {
		if(amount > 0) {
${offsetSteps.map(step => `
			while((amount / ${step}) > 0) {
				this.offsetPY${step}();
				amount -= ${step};
			}
`.slice(1, -1)).join("\n")}
		} else {
			amount *= -1;
${offsetSteps.map(step => `
			while((amount / ${step}) > 0) {
				this.offsetNY${step}();
				amount -= ${step};
			}
`.slice(1, -1)).join("\n")}
		}
		assert amount == 0;
	}
${offsetSteps.map(step => `
${generateSourceOffsetXYZ(`offsetPY${step}`, 0, step, 0)}
`.slice(1, -1)).join("\n")}
${offsetSteps.map(step => `
${generateSourceOffsetXYZ(`offsetNY${step}`, 0, -step, 0)}
`.slice(1, -1)).join("\n")}

	public void offsetZ(int amount) {
		if(amount > 0) {
${offsetSteps.map(step => `
			while((amount / ${step}) > 0) {
				this.offsetPZ${step}();
				amount -= ${step};
			}
`.slice(1, -1)).join("\n")}
		} else {
			amount *= -1;
${offsetSteps.map(step => `
			while((amount / ${step}) > 0) {
				this.offsetNZ${step}();
				amount -= ${step};
			}
`.slice(1, -1)).join("\n")}
		}
		assert amount == 0;
	}
${offsetSteps.map(step => `
${generateSourceOffsetXYZ(`offsetPZ${step}`, 0, 0, step)}
`.slice(1, -1)).join("\n")}
${offsetSteps.map(step => `
${generateSourceOffsetXYZ(`offsetNZ${step}`, 0, 0, -step)}
`.slice(1, -1)).join("\n")}

	public void complement() {
${new Array(slotBatch).fill().map((_, i) => i).map(i => `		this.complement${i}();`).join("\n")}
	}
${new Array(slotBatch).fill().map((_, i) => i).map(i => `
	protected void complement${i}() {
${new Array(batch).fill().map((_, j) => i * batch + j).filter(j => j < slots).map(j => `		this._${j} = ~this._${j};`).join("\n")}
	}
`.slice(1, -1)).join("\n")}

	public boolean isIntersecting(BitField that0) {
		if(!(that0 instanceof ${Class}))
			return BitField.super.isIntersecting(that0);
		var that = (${Class}) that0;
${new Array(slotBatch).fill().map((_, i) => i).map(i => `		if(this.isIntersecting${i}(that)) return true;`).join("\n")}
		return false;
	}
${new Array(slotBatch).fill().map((_, i) => i).map(i => `
	protected boolean isIntersecting${i}(${Class} that) {
${new Array(batch).fill().map((_, j) => i * batch + j).filter(j => j < slots).map(j => `		if((this._${j} & that._${j}) != 0) return true;`).join("\n")}
		return false;
	}
`.slice(1, -1)).join("\n")}

	public void union(BitField that0) {
		if(!(that0 instanceof ${Class})) {
			BitField.super.union(that0);
			return;
		}
		var that = (${Class}) that0;
${new Array(slotBatch).fill().map((_, i) => i).map(i => `		this.union${i}(that);`).join("\n")}
	}
${new Array(slotBatch).fill().map((_, i) => i).map(i => `
	protected void union${i}(${Class} that) {
${new Array(batch).fill().map((_, j) => i * batch + j).filter(j => j < slots).map(j => `		this._${j} |= that._${j};`).join("\n")}
	}
`.slice(1, -1)).join("\n")}

	public void intersect(BitField that0) {
		if(!(that0 instanceof ${Class})) {
			BitField.super.union(that0);
			return;
		}
		var that = (${Class}) that0;
${new Array(slotBatch).fill().map((_, i) => i).map(i => `		this.intersect${i}(that);`).join("\n")}
	}
${new Array(slotBatch).fill().map((_, i) => i).map(i => `
	protected void intersect${i}(${Class} that) {
${new Array(batch).fill().map((_, j) => i * batch + j).filter(j => j < slots).map(j => `		this._${j} &= that._${j};`).join("\n")}
	}
`.slice(1, -1)).join("\n")}

	public void exclusive(BitField that0) {
		if(!(that0 instanceof ${Class})) {
			BitField.super.union(that0);
			return;
		}
		var that = (${Class}) that0;
${new Array(slotBatch).fill().map((_, i) => i).map(i => `		this.exclusive${i}(that);`).join("\n")}
	}
${new Array(slotBatch).fill().map((_, i) => i).map(i => `
	protected void exclusive${i}(${Class} that) {
${new Array(batch).fill().map((_, j) => i * batch + j).filter(j => j < slots).map(j => `		this._${j} ^= that._${j};`).join("\n")}
	}
`.slice(1, -1)).join("\n")}

	public void subtract(BitField that0) {
		if(!(that0 instanceof ${Class})) {
			BitField.super.union(that0);
			return;
		}
		var that = (${Class}) that0;
${new Array(slotBatch).fill().map((_, i) => i).map(i => `		this.subtract${i}(that);`).join("\n")}
	}
${new Array(slotBatch).fill().map((_, i) => i).map(i => `
	protected void subtract${i}(${Class} that) {
${new Array(batch).fill().map((_, j) => i * batch + j).filter(j => j < slots).map(j => `		this._${j} &= ~that._${j};`).join("\n")}
	}
`.slice(1, -1)).join("\n")}
}
`;
	// console.log(source);

	const outputFile = path.join(__dirname, `${Class}.java`);
	console.log(`Generated ${outputFile}`);
	await fs.writeFile(outputFile, source, "utf-8");
}

await generateSource({
	width: 8,
	height: 8,
	depth: 1,
	batch: 16
});
await generateSource({
	width: 8,
	height: 8,
	depth: 8,
	batch: 16
});
await generateSource({
	width: 12,
	height: 12,
	depth: 1,
	batch: 16
});
await generateSource({
	width: 12,
	height: 12,
	depth: 12,
	batch: 16
});
await generateSource({
	width: 16,
	height: 16,
	depth: 16,
	batch: 16
});
await generateSource({
	width: 16,
	height: 16,
	depth: 1,
	batch: 16
});
await generateSource({
	width: 20,
	height: 20,
	depth: 1,
	batch: 16
});
await generateSource({
	width: 20,
	height: 20,
	depth: 10,
	batch: 16
});
await generateSource({
	width: 32,
	height: 32,
	depth: 1,
	batch: 16
});
await generateSource({
	width: 32,
	height: 32,
	depth: 8,
	batch: 16
});
